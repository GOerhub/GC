{"mappings":"AAAA,yBAAyB;AACzB,4CAA4C;AAC5C,8CAA8C;AAC9C,2EAA2E;AAC3E,mEAAmE;AACnE,+CAA+C;AAE9C,CAAA,SAAS,UAAU,EAAE;IAClB,2BAA2B,CAC3B,IAAG,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,CAAC,OAAO,KAAK,QAAQ,EAC/D,MAAM,CAAC,OAAO,GAAG,UAAU,EAAE,CAAC;SAC3B,IAAG,OAAO,MAAM,KAAK,UAAU,IAAI,MAAM,CAAC,GAAG,EAChD,MAAM,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;SACpB;QACH,IAAI,OAAO,GAAG,UAAU,EAAE,AAAC;QAC3B,MAAM,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QAC7B,MAAM,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;KAChC;CACJ,CAAA,CAAE,WAAW;IAEd,SAAS,MAAM,CAAC,IAAI,EAAC;QACjB,IAAI,IAAI,GAAG,IAAI,EACX,IAAI,GAAG,EAAE,AAAC;QACd,MAAM,IAAI,CAAC,MAAM,CAAE;YACf,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAChB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;SACtB;QACD,OAAO,IAAI,CAAC,OAAO,EAAE,CAAC;KACzB;IAED,SAAS,OAAO,GAAG;QACf,OAAO,IAAI,UAAU,CAAC,SAAS,IAAI,EAAE;YACjC,OAAO,IAAI,CAAC,CAAC,CAAC;SACjB,CAAC,CAAC;KACN;IAED,IAAI,KAAK,GAAG;QACR,IAAI,EAAE,SAAS,KAAK,EAAE;YAClB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,CAAE;gBACpD,IAAI,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,AAAC;gBAC1B,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;gBACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;gBACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;gBACX,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;gBACrB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;gBACpB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;aACtB;SACJ;QAED;;;;;;;;;;MAUE,CACF,MAAM,EAAE,SAAS,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,OAAO,EAAE;YACzC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAElB,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;YACxB,IAAI,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC,SAAS,EAC3D,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,KAAK,AAAC;YAEvC,IAAI,QAAQ,GAAG,OAAO,EAAE,EACpB,WAAW,GAAG,KAAK,AAAC,EAAC,mDAAmD;YAE5E,KAAK,CAAC,CAAC,GAAG,SAAS,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;YAEhC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAErB,MAAM,QAAQ,CAAC,IAAI,EAAE,GAAG,CAAC,CAAE;gBAEvB,wEAAwE;gBACxE,IAAI,WAAW,GAAG,QAAQ,CAAC,GAAG,EAAE,AAAC;gBAEjC,6DAA6D;gBAC7D,IAAG,WAAW,KAAK,GAAG,EAClB,OAAO,MAAM,CAAC,WAAW,CAAC,CAAC;gBAG/B,sFAAsF;gBACtF,WAAW,CAAC,MAAM,GAAG,IAAI,CAAC;gBAE1B,2CAA2C;gBAC3C,IAAI,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,WAAW,CAAC,AAAC;gBAE7C,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,CAAE;oBAChD,IAAI,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,AAAC;oBAE5B,IAAI,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,EAAE,EAEpC,SAAS;oBAGb,mEAAmE;oBACnE,sGAAsG;oBACtG,IAAI,MAAM,GAAG,WAAW,CAAC,CAAC,GAAG,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAC,EACtD,WAAW,GAAG,QAAQ,CAAC,OAAO,AAAC;oBAEnC,IAAI,CAAC,WAAW,IAAI,MAAM,GAAG,QAAQ,CAAC,CAAC,EAAE;wBAErC,2FAA2F;wBAC3F,QAAQ,CAAC,OAAO,GAAG,IAAI,CAAC;wBACxB,QAAQ,CAAC,MAAM,GAAG,WAAW,CAAC;wBAC9B,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,IAAI,SAAS,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;wBACpD,QAAQ,CAAC,CAAC,GAAG,MAAM,CAAC;wBACpB,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC;wBAErC,IAAI,OAAO,EACP,2FAA2F;wBAC3F,gFAAgF;wBAChF;4BAAA,IAAI,QAAQ,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,IAAK,QAAQ,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,AAAC,EAC1F,WAAW,GAAG,QAAQ,CAAC;yBAC1B,AACJ;wBAED,IAAI,CAAC,WAAW,EACZ,sEAAsE;wBACtE,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;6BAGxB,0FAA0F;wBAC1F,QAAQ,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;qBAEzC;iBACJ;aACJ;YAED,IAAI,OAAO,EACP,OAAO,MAAM,CAAC,WAAW,CAAC,CAAC;YAG/B,oEAAoE;YACpE,OAAO,EAAE,CAAC;SACb;QACD,4FAA4F;QAC5F,UAAU,EAAE;YACR,SAAS,EAAE,SAAS,IAAI,EAAE,IAAI,EAAE;gBAC5B,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,AAAC;gBACnC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,AAAC;gBACnC,OAAO,EAAE,GAAG,EAAE,CAAC;aAClB;YACD,QAAQ,EAAE,SAAS,IAAI,EAAE,IAAI,EAAE;gBAC3B,IAAI,CAAC,GAAG,CAAC,AAAC;gBACV,IAAI,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,AAAC;gBACtB,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,AAAC;gBACnC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,AAAC;gBACnC,OAAO,AAAC,CAAC,GAAI,CAAA,EAAE,GAAG,EAAE,CAAA,GAAM,AAAC,CAAA,EAAE,GAAI,CAAC,GAAG,CAAC,AAAC,CAAA,GAAI,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,AAAC,CAAC;aAChE;SACJ;KACJ,AAAC;IAEF;;;;;EAKE,CACF,SAAS,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE;QAC5B,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QACxB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC;QACnC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;QACf,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;YACpC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;YAElB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;gBAClD,IAAI,IAAI,GAAG,IAAI,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,AAAC;gBACtC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;gBACvB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACzB;SACJ;KACJ;IAED,KAAK,CAAC,SAAS,CAAC,SAAS,GAAG,SAAS,IAAI,EAAE;QACvC,IAAI,GAAG,GAAG,EAAE,EACR,CAAC,GAAG,IAAI,CAAC,CAAC,EACV,CAAC,GAAG,IAAI,CAAC,CAAC,EACV,IAAI,GAAG,IAAI,CAAC,IAAI,AAAC;QAErB,OAAO;QACP,IAAG,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACxB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAG3B,OAAO;QACP,IAAG,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EACxB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAG3B,QAAQ;QACR,IAAG,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,EACtB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;QAG3B,QAAQ;QACR,IAAG,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,EACtB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;QAG3B,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,YAAY;YACZ,IAAG,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,EAC1B,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;YAG7B,YAAY;YACZ,IAAG,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,EAC1B,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;YAG7B,YAAY;YACZ,IAAG,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,EAC1B,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;YAG7B,YAAY;YACZ,IAAG,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,EAC1B,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;SAEhC;QAED,OAAO,GAAG,CAAC;KACd,CAAC;IAEF,KAAK,CAAC,SAAS,CAAC,QAAQ,GAAG,WAAW;QAClC,IAAI,WAAW,GAAG,EAAE,EAChB,KAAK,GAAG,IAAI,CAAC,IAAI,EACjB,QAAQ,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,AAAC;QACxB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,CAAE;YAC9C,QAAQ,GAAG,EAAE,CAAC;YACd,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACf,IAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAClC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;YAEjC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;SACxC;QACD,OAAO,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACjC,CAAC;IAEF,SAAS,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE;QAC5B,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;QACX,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;KACxB;IAED,QAAQ,CAAC,SAAS,CAAC,QAAQ,GAAG,WAAW;QACrC,OAAO,GAAG,GAAG,IAAI,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC;KAC5C,CAAC;IAEF,QAAQ,CAAC,SAAS,CAAC,OAAO,GAAG,WAAW;QACpC,OAAO,IAAI,CAAC,MAAM,CAAC;KACtB,CAAC;IAEF,QAAQ,CAAC,SAAS,CAAC,MAAM,GAAG,WAAW;QACnC,OAAO,IAAI,CAAC,MAAM,KAAK,CAAC,CAAC;KAC5B,CAAC;IAEF,SAAS,UAAU,CAAC,aAAa,EAAC;QAC9B,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QAClB,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;KACtC;IAED,UAAU,CAAC,SAAS,GAAG;QACnB,IAAI,EAAE,SAAS,OAAO,EAAE;YACpB,+CAA+C;YAC/C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAE3B,yBAAyB;YACzB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC1C;QACD,GAAG,EAAE,WAAW;YACZ,qDAAqD;YACrD,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,AAAC;YAC7B,2CAA2C;YAC3C,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,AAAC;YAC7B,6DAA6D;YAC7D,+BAA+B;YAC/B,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzB,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;gBACtB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;aACpB;YACD,OAAO,MAAM,CAAC;SACjB;QACD,MAAM,EAAE,SAAS,IAAI,EAAE;YACnB,IAAI,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,AAAC;YAEnC,0DAA0D;YAC1D,uBAAuB;YACvB,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,AAAC;YAE7B,IAAI,CAAC,KAAK,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC/B,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC;gBAEtB,IAAI,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAClD,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;qBAGjB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;aAExB;SACJ;QACD,IAAI,EAAE,WAAW;YACb,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;SAC9B;QACD,cAAc,EAAE,SAAS,IAAI,EAAE;YAC3B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;SAC7C;QACD,QAAQ,EAAE,SAAS,CAAC,EAAE;YAClB,yCAAyC;YACzC,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,AAAC;YAE9B,kDAAkD;YAClD,MAAO,CAAC,GAAG,CAAC,CAAE;gBAEV,oDAAoD;gBACpD,IAAI,OAAO,GAAG,AAAC,CAAA,AAAC,CAAC,GAAG,CAAC,IAAK,CAAC,CAAA,GAAI,CAAC,EAC5B,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,AAAC;gBACnC,8CAA8C;gBAC9C,IAAI,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE;oBAC1D,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;oBAChC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC;oBACzB,8CAA8C;oBAC9C,CAAC,GAAG,OAAO,CAAC;iBACf,MAGG,MAAM;aAEb;SACJ;QACD,QAAQ,EAAE,SAAS,CAAC,EAAE;YAClB,4CAA4C;YAC5C,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAC5B,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EACzB,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,AAAC;YAE5C,MAAM,IAAI,CAAE;gBACR,6CAA6C;gBAC7C,IAAI,OAAO,GAAG,AAAC,CAAC,GAAG,CAAC,IAAK,CAAC,EACtB,OAAO,GAAG,OAAO,GAAG,CAAC,AAAC;gBAC1B,iEAAiE;gBACjE,IAAI,IAAI,GAAG,IAAI,EACX,WAAW,AAAC;gBAChB,qDAAqD;gBACrD,IAAI,OAAO,GAAG,MAAM,EAAE;oBAClB,oCAAoC;oBACpC,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,AAAC;oBACnC,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;oBAEzC,4DAA4D;oBAC5D,IAAI,WAAW,GAAG,SAAS,EACvB,IAAI,GAAG,OAAO,CAAC;iBAEtB;gBAED,0CAA0C;gBAC1C,IAAI,OAAO,GAAG,MAAM,EAAE;oBAClB,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAC9B,WAAW,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,AAAC;oBAC7C,IAAI,WAAW,GAAI,CAAA,IAAI,KAAK,IAAI,GAAG,SAAS,GAAG,WAAW,CAAA,AAAC,EACvD,IAAI,GAAG,OAAO,CAAC;iBAEtB;gBAED,2DAA2D;gBAC3D,IAAI,IAAI,KAAK,IAAI,EAAE;oBACf,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oBACrC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC;oBAC7B,CAAC,GAAG,IAAI,CAAC;iBACZ,MAGG,MAAM;aAEb;SACJ;KACJ,CAAC;IAEF,OAAO;QACH,KAAK,EAAE,KAAK;QACZ,KAAK,EAAE,KAAK;KACf,CAAC;CAED,CAAC,CAAC","sources":["js/astar.js"],"sourcesContent":["// javascript-astar 0.3.0\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\n(function(definition) {\n    /* global module, define */\n    if(typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = definition();\n    } else if(typeof define === 'function' && define.amd) {\n        define([], definition);\n    } else {\n        var exports = definition();\n        window.astar = exports.astar;\n        window.Graph = exports.Graph;\n    }\n})(function() {\n\nfunction pathTo(node){\n    var curr = node,\n        path = [];\n    while(curr.parent) {\n        path.push(curr);\n        curr = curr.parent;\n    }\n    return path.reverse();\n}\n\nfunction getHeap() {\n    return new BinaryHeap(function(node) {\n        return node.f;\n    });\n}\n\nvar astar = {\n    init: function(graph) {\n        for (var i = 0, len = graph.nodes.length; i < len; ++i) {\n            var node = graph.nodes[i];\n            node.f = 0;\n            node.g = 0;\n            node.h = 0;\n            node.visited = false;\n            node.closed = false;\n            node.parent = null;\n        }\n    },\n\n    /**\n    * Perform an A* Search on a graph given a start and end node.\n    * @param {Graph} graph\n    * @param {GridNode} start\n    * @param {GridNode} end\n    * @param {Object} [options]\n    * @param {bool} [options.closest] Specifies whether to return the\n               path to the closest node if the target is unreachable.\n    * @param {Function} [options.heuristic] Heuristic function (see\n    *          astar.heuristics).\n    */\n    search: function(graph, start, end, options) {\n        astar.init(graph);\n\n        options = options || {};\n        var heuristic = options.heuristic || astar.heuristics.manhattan,\n            closest = options.closest || false;\n\n        var openHeap = getHeap(),\n            closestNode = start; // set the start node to be the closest if required\n\n        start.h = heuristic(start, end);\n\n        openHeap.push(start);\n\n        while(openHeap.size() > 0) {\n\n            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n            var currentNode = openHeap.pop();\n\n            // End case -- result has been found, return the traced path.\n            if(currentNode === end) {\n                return pathTo(currentNode);\n            }\n\n            // Normal case -- move currentNode from open to closed, process each of its neighbors.\n            currentNode.closed = true;\n\n            // Find all neighbors for the current node.\n            var neighbors = graph.neighbors(currentNode);\n\n            for (var i = 0, il = neighbors.length; i < il; ++i) {\n                var neighbor = neighbors[i];\n\n                if (neighbor.closed || neighbor.isWall()) {\n                    // Not a valid node to process, skip to next neighbor.\n                    continue;\n                }\n\n                // The g score is the shortest distance from start to current node.\n                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n                var gScore = currentNode.g + neighbor.getCost(currentNode),\n                    beenVisited = neighbor.visited;\n\n                if (!beenVisited || gScore < neighbor.g) {\n\n                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n                    neighbor.visited = true;\n                    neighbor.parent = currentNode;\n                    neighbor.h = neighbor.h || heuristic(neighbor, end);\n                    neighbor.g = gScore;\n                    neighbor.f = neighbor.g + neighbor.h;\n\n                    if (closest) {\n                        // If the neighbour is closer than the current closestNode or if it's equally close but has\n                        // a cheaper path than the current closest node then it becomes the closest node\n                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {\n                            closestNode = neighbor;\n                        }\n                    }\n\n                    if (!beenVisited) {\n                        // Pushing to heap will put it in proper place based on the 'f' value.\n                        openHeap.push(neighbor);\n                    }\n                    else {\n                        // Already seen the node, but since it has been rescored we need to reorder it in the heap\n                        openHeap.rescoreElement(neighbor);\n                    }\n                }\n            }\n        }\n\n        if (closest) {\n            return pathTo(closestNode);\n        }\n\n        // No result was found - empty array signifies failure to find path.\n        return [];\n    },\n    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n    heuristics: {\n        manhattan: function(pos0, pos1) {\n            var d1 = Math.abs(pos1.x - pos0.x);\n            var d2 = Math.abs(pos1.y - pos0.y);\n            return d1 + d2;\n        },\n        diagonal: function(pos0, pos1) {\n            var D = 1;\n            var D2 = Math.sqrt(2);\n            var d1 = Math.abs(pos1.x - pos0.x);\n            var d2 = Math.abs(pos1.y - pos0.y);\n            return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));\n        }\n    }\n};\n\n/**\n* A graph memory structure\n* @param {Array} gridIn 2D array of input weights\n* @param {Object} [options]\n* @param {bool} [options.diagonal] Specifies whether diagonal moves are allowed\n*/\nfunction Graph(gridIn, options) {\n    options = options || {};\n    this.nodes = [];\n    this.diagonal = !!options.diagonal;\n    this.grid = [];\n    for (var x = 0; x < gridIn.length; x++) {\n        this.grid[x] = [];\n\n        for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n            var node = new GridNode(x, y, row[y]);\n            this.grid[x][y] = node;\n            this.nodes.push(node);\n        }\n    }\n}\n\nGraph.prototype.neighbors = function(node) {\n    var ret = [],\n        x = node.x,\n        y = node.y,\n        grid = this.grid;\n\n    // West\n    if(grid[x-1] && grid[x-1][y]) {\n        ret.push(grid[x-1][y]);\n    }\n\n    // East\n    if(grid[x+1] && grid[x+1][y]) {\n        ret.push(grid[x+1][y]);\n    }\n\n    // South\n    if(grid[x] && grid[x][y-1]) {\n        ret.push(grid[x][y-1]);\n    }\n\n    // North\n    if(grid[x] && grid[x][y+1]) {\n        ret.push(grid[x][y+1]);\n    }\n\n    if (this.diagonal) {\n        // Southwest\n        if(grid[x-1] && grid[x-1][y-1]) {\n            ret.push(grid[x-1][y-1]);\n        }\n\n        // Southeast\n        if(grid[x+1] && grid[x+1][y-1]) {\n            ret.push(grid[x+1][y-1]);\n        }\n\n        // Northwest\n        if(grid[x-1] && grid[x-1][y+1]) {\n            ret.push(grid[x-1][y+1]);\n        }\n\n        // Northeast\n        if(grid[x+1] && grid[x+1][y+1]) {\n            ret.push(grid[x+1][y+1]);\n        }\n    }\n\n    return ret;\n};\n\nGraph.prototype.toString = function() {\n    var graphString = [],\n        nodes = this.grid, // when using grid\n        rowDebug, row, y, l;\n    for (var x = 0, len = nodes.length; x < len; x++) {\n        rowDebug = [];\n        row = nodes[x];\n        for (y = 0, l = row.length; y < l; y++) {\n            rowDebug.push(row[y].weight);\n        }\n        graphString.push(rowDebug.join(\" \"));\n    }\n    return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n    this.x = x;\n    this.y = y;\n    this.weight = weight;\n}\n\nGridNode.prototype.toString = function() {\n    return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function() {\n    return this.weight;\n};\n\nGridNode.prototype.isWall = function() {\n    return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction){\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n    push: function(element) {\n        // Add the new element to the end of the array.\n        this.content.push(element);\n\n        // Allow it to sink down.\n        this.sinkDown(this.content.length - 1);\n    },\n    pop: function() {\n        // Store the first element so we can return it later.\n        var result = this.content[0];\n        // Get the element at the end of the array.\n        var end = this.content.pop();\n        // If there are any elements left, put the end element at the\n        // start, and let it bubble up.\n        if (this.content.length > 0) {\n            this.content[0] = end;\n            this.bubbleUp(0);\n        }\n        return result;\n    },\n    remove: function(node) {\n        var i = this.content.indexOf(node);\n\n        // When it is found, the process seen in 'pop' is repeated\n        // to fill up the hole.\n        var end = this.content.pop();\n\n        if (i !== this.content.length - 1) {\n            this.content[i] = end;\n\n            if (this.scoreFunction(end) < this.scoreFunction(node)) {\n                this.sinkDown(i);\n            }\n            else {\n                this.bubbleUp(i);\n            }\n        }\n    },\n    size: function() {\n        return this.content.length;\n    },\n    rescoreElement: function(node) {\n        this.sinkDown(this.content.indexOf(node));\n    },\n    sinkDown: function(n) {\n        // Fetch the element that has to be sunk.\n        var element = this.content[n];\n\n        // When at 0, an element can not sink any further.\n        while (n > 0) {\n\n            // Compute the parent element's index, and fetch it.\n            var parentN = ((n + 1) >> 1) - 1,\n                parent = this.content[parentN];\n            // Swap the elements if the parent is greater.\n            if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                this.content[parentN] = element;\n                this.content[n] = parent;\n                // Update 'n' to continue at the new position.\n                n = parentN;\n            }\n            // Found a parent that is less, no need to sink any further.\n            else {\n                break;\n            }\n        }\n    },\n    bubbleUp: function(n) {\n        // Look up the target element and its score.\n        var length = this.content.length,\n            element = this.content[n],\n            elemScore = this.scoreFunction(element);\n\n        while(true) {\n            // Compute the indices of the child elements.\n            var child2N = (n + 1) << 1,\n                child1N = child2N - 1;\n            // This is used to store the new position of the element, if any.\n            var swap = null,\n                child1Score;\n            // If the first child exists (is inside the array)...\n            if (child1N < length) {\n                // Look it up and compute its score.\n                var child1 = this.content[child1N];\n                child1Score = this.scoreFunction(child1);\n\n                // If the score is less than our element's, we need to swap.\n                if (child1Score < elemScore){\n                    swap = child1N;\n                }\n            }\n\n            // Do the same checks for the other child.\n            if (child2N < length) {\n                var child2 = this.content[child2N],\n                    child2Score = this.scoreFunction(child2);\n                if (child2Score < (swap === null ? elemScore : child1Score)) {\n                    swap = child2N;\n                }\n            }\n\n            // If the element needs to be moved, swap it, and continue.\n            if (swap !== null) {\n                this.content[n] = this.content[swap];\n                this.content[swap] = element;\n                n = swap;\n            }\n            // Otherwise, we are done.\n            else {\n                break;\n            }\n        }\n    }\n};\n\nreturn {\n    astar: astar,\n    Graph: Graph\n};\n\n});\n"],"names":[],"version":3,"file":"index.47ec2109.js.map","sourceRoot":"/__parcel_source_root/"}